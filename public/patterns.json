[
   {
      "slug": "arrays-hashing",
      "name": "Arrays & Hashing",
      "description": "Problems based on arrays, hash maps, and counting techniques",
      "subpatterns": [
         {
            "slug": "array-fundamentals",
            "name": "Fundamentals",
            "description": "Basic operations and traversal patterns on arrays, including iteration, indexing, and simple element comparisons"
         },
         {
            "slug": "frequency-map",
            "name": "Frequency Map",
            "description": "Counting occurrences of elements or characters to solve problems involving duplicates, anagrams, or distributions"
         },
         {
            "slug": "prefix-sum-product",
            "name": "Prefix Sum / Product",
            "description": "Precomputing cumulative sums or products to answer range queries or optimize subarray calculations in O(1)"
         },
         {
            "slug": "last-seen-index",
            "name": "Last Seen Index",
            "description": "Tracking last occurrence index to reason about distance, order, or uniqueness"
         },
         {
            "slug": "matrix",
            "name": "Matrix",
            "description": "Working with 2D arrays: row/column access, bounds handling, and basic traversal patterns"
         }
      ]
   },
   {
      "slug": "linked-list",
      "name": "Linked List",
      "description": "Problems involving singly or doubly linked lists, including traversal, insertion, deletion, reversal, and pointer manipulation"
   },
   {
      "slug": "two-pointers",
      "name": "Two Pointers",
      "description": "Problems solved by maintaining two indices that move monotonically to traverse data efficiently",
      "subpatterns": [
         {
            "slug": "opposite-ends",
            "name": "Opposite Ends",
            "description": "Two pointers start from both ends and move toward each other; used for pair searching, palindrome checks, in-place reverse, and greedy pairing"
         },
         {
            "slug": "same-direction",
            "name": "Same Direction",
            "description": "Both pointers move forward; often a slow/fast pointer setup for deduplication, filtering, partitioning, or window-like optimizations"
         },
         {
            "slug": "two-arrays",
            "name": "Two Arrays Traversal",
            "description": "Two pointers iterate over two separate arrays to combine, compare, or compute relationships between elements; used for counting pairs, intersections, unions, or range-based relations"
         }
      ]
   },
   {
      "slug": "sliding-window",
      "name": "Sliding Window",
      "description": "Window-based problems with fixed or variable size",
      "subpatterns": [
         {
            "slug": "fixed-size-sliding-window",
            "name": "Fixed Size Sliding Window",
            "description": "Problems where the window length is constant; compute sums, counts, or max/min within the window"
         },
         {
            "slug": "longest-sliding-window",
            "name": "Longest Sliding Window",
            "description": "Expand the window as much as possible while maintaining validity; typically used to find the longest subarray or substring satisfying a condition"
         },
         {
            "slug": "shortest-sliding-window",
            "name": "Shortest Sliding Window",
            "description": "Shrink the window as much as possible while maintaining validity; typically used to find the shortest subarray or substring satisfying a condition"
         }
      ]
   },
   {
      "slug": "binary-search",
      "name": "Binary Search",
      "description": "Divide search space in half using monotonic property"
   },
   {
      "slug": "stack",
      "name": "Stack",
      "description": "LIFO data structure problems; used for sequential processing, undo-like logic, expression evaluation, and optimization",
      "subpatterns": [
         {
            "slug": "stack-fundamentals",
            "name": "Fundamentals",
            "description": "Sequential processing of elements; last-in, first-out logic; undo-like operations"
         },
         {
            "slug": "monotonic-stack",
            "name": "Monotonic Stack",
            "description": "Maintains strictly increasing or decreasing order; used for next greater/smaller element or range queries"
         },
         {
            "slug": "expression-evaluation",
            "name": "Expression Evaluation",
            "description": "Parsing and evaluating expressions using a stack; includes postfix/prefix notation, infix calculators, operator precedence, and intermediate results"
         }
      ]
   },
   {
      "slug": "queue-deque",
      "name": "Queue & Deque",
      "description": "FIFO data structure and double-ended queue problems; used for sequential processing, sliding window optimizations, and breadth-first search",
      "subpatterns": [
         {
            "slug": "queue-deque-fundamentals",
            "name": "Fundamentals",
            "description": "FIFO (First-In-First-Out) logic for sequential task processing and basic queue operations like push, pop, and peek"
         },
         {
            "slug": "monotonic-deque",
            "name": "Monotonic Deque",
            "description": "Maintaining a deque in increasing or decreasing order to optimize finding the range max/min in O(n) time, commonly used in sliding window problems"
         },
         {
            "slug": "circular-queue",
            "name": "Circular Queue / Design",
            "description": "Efficiently managing a fixed-size buffer using head and tail pointers to avoid memory re-allocation or handle streaming data"
         },
         {
            "slug": "priority-queue",
            "name": "Priority Queue / Heap",
            "description": "Queue where each element has a priority; supports efficiently extracting the min or max element, and commonly used for top-k, median, or greedy selection problems"
         }
      ]
   },
   {
      "slug": "tree",
      "name": "Tree",
      "description": "Problems involving binary or n-ary trees, including traversal, path computation, and subtree calculations",
      "subpatterns": [
         {
            "slug": "tree-bfs",
            "name": "BFS Level-Order",
            "description": "Traverse tree level by level, useful for width, min depth, right side view, or zigzag order"
         },
         {
            "slug": "tree-dfs-top-down",
            "name": "DFS Top-Down (Pre-order)",
            "description": "Pass state from parent to children to solve path or accumulation problems"
         },
         {
            "slug": "tree-dfs-bottom-up",
            "name": "DFS Bottom-Up (Post-order)",
            "description": "Compute values from children to parent"
         },
         {
            "slug": "binary-search-tree",
            "name": "Binary Search Tree (BST)",
            "description": "Leverage BST properties (left < root < right) for efficient searching, insertion, deletion, and inorder traversal"
         }
      ]
   },
   {
      "slug": "graph",
      "name": "Graph",
      "description": "Problems involving vertices and edges, including traversal, connectivity, shortest paths, and graph algorithms",
      "subpatterns": [
         {
            "slug": "graph-bfs",
            "name": "BFS",
            "description": "Level-order traversal for shortest paths, reachability, or propagation effects"
         },
         {
            "slug": "graph-dfs",
            "name": "DFS",
            "description": "Recursive or stack-based traversal for exploring connected components, paths, or detecting cycles"
         },
         {
            "slug": "union-find",
            "name": "Union-Find / Disjoint Set",
            "description": "Tracking connected components or detecting cycles efficiently using a disjoint set structure. Example: 'Redundant Connection', 'Number of Connected Components in an Undirected Graph'"
         }
      ]
   },
   {
      "slug": "greedy",
      "name": "Greedy",
      "description": "Problems where a local optimal choice at each step leads to a global optimum",
      "subpatterns": [
         {
            "slug": "local-optimal-choice",
            "name": "Local Optimal Choice",
            "description": "Choose the best option at each step based on local conditions, without revisiting previous decisions"
         }
      ]
   },
   {
      "slug": "design",
      "name": "Design",
      "description": "Problems that require designing classes, APIs, or data structures with specific operations and constraints"
   },
   {
      "slug": "dynamic-programming",
      "name": "Dynamic Programming",
      "description": "Problems solved by breaking them into overlapping subproblems and reusing previously computed results to optimize time complexity",
      "subpatterns": [
         {
            "slug": "dp-1d-linear",
            "name": "1D Linear DP",
            "description": "Problems where the state depends on previous indices in a linear order; typically dp[i] depends on dp[i-1], dp[i-2], etc. Example: Fibonacci, Tribonacci, Climbing Stairs"
         }
      ]
   },
   {
      "slug": "math",
      "name": "Math",
      "description": "Problems involving number theory, arithmetic, and bitwise operations to solve problems efficiently",
      "subpatterns": [
         {
            "slug": "bit-manipulation",
            "name": "Bit Manipulation",
            "description": "Use bitwise operations like XOR, AND, OR, shifts to solve problems efficiently with constant space"
         }
      ]
   },
   {
      "slug": "db",
      "name": "Database",
      "description": "SQL database queries and operations"
   }
]